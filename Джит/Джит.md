**git commit** **-m** - фиксация или моментальный снимок нашего рабочего каталога с некоторыми метаданными, а именно временем и комментарием
**git checkout** - меняет указатель Head на определенную ветку 
**git checkout -b** (git branch + git checkout) - создает новую ветку и меняет указатель Head на нее 

Git хранит все объекты в своем репозитории, и хранит их в подкаталогах внутри каталога objects. Подкаталоги именуются по первым двум символам хеша объекта, а оставшиеся 38 символов хеша используются в качестве имени файла то есть, когда мы добавляем новый объект (например, файл или коммит) в репозиторий Git, он сначала вычисляет хеш для этого объекта, затем он сжимает объект и сохраняет его в файле внутри подкаталога objects. Имя этого файла - это хеш объекта, за исключением первых двух символов, которые используются для имени подкаталога. Также в репозитории есть папка refs, где git хранит ссылки или указатели на коммиты.
Каталог **heads** определяет все локальные ветки в нашем репозитории. Каждое имя файла соответствует имени соответствующей ветки, а внутри файла хеш коммитов
Каталог **remotes** содержит ссылки на ветки удаленных репозиториев.
Каталог **tags** содержит ссылки на теги.

Для того, чтобы создать репозиторий git в рабочей директории используется команда - **git init**


Чтобы добавить в индекс (так называемую промежуточную область) какой либо файл, то есть чтобы гит его отслеживал и мы могли его зафиксировать мы используем команду - **git add**
Для того чтобы посмотреть историю зафиксированных изменений мы можем использовать - **git** **log**, а для того чтобы проверить состояние файлов нашей директории - **git status**

**git rm --cached** - удаление файла из индекса, в рабочем останется
**git rm**

При каждом новом коммите указатель Head (который указывает на мастер) будет указывает на последний коммит, чтобы убедиться можно использовать команду **git** **rev**-**parse** **HEAD** **(либо** HEAD-1)

**Смещенный указатель –** ситуация когда мы переключаемся между комитами с помощью **git** **checkout** **<commit_*id***>

**git add -A :** добавляет все изменения (новые, измененные, удаленные файлы (**git**_ _**add**_ _**. – удаленные не отслеживает**_)) в текущем каталоге и всех его подкаталогов в индекс для следующего коммита

**git commit -a** автоматически добавляет все измененные (т.е., уже отслеживаемые) файлы в индекс и делает коммит. Это не включает новые (неотслеживаемые) файлы.

**RESET**
 
Для того чтобы отменить наши действия, можно использовать команду **git reset**, она имеет 3 основных режима –hard –mixed –soft. И первый шаг git reset не зависимо от режима который мы указываем, заключается в перемещении того, на что указывает HEAD,

если мы используем **soft** режим, он просто меняет указатель HEAD при этом старые коммиты остаются в истории репозитория, и все файлы останутся в индексации (в staging area), так же как и в рабочей директории, достаточно сделать коммит, но это уже будет другой объект гит.

если мы используем **mixed** режим, то он уже не оставляет файлы в индексации, при этом изменения остаются в рабочем каталоге для дальнейшего коммита. Идет по умолчанию. (можно разделить коммит на 2 разных)

**Hard** – очищает как индексацию, так и рабочую директорию

**git reset --merge** - откатывает до указанного комита, при конфликте сливания двух веток, отменяет операцию слияния и возвращает в исходное состояние 

**git** **revert** – отменяет изменения предыдущего комита, путем создания нового комита.

**git** **log** – посмотреть историю коммитов **(git log --graph –oneline** (иерархическая структура коммитов**) –**decorate** (покажет указатели веток))

**git reflog** - используется для отображения истории операций в репозитории Git. Она показывает список всех действий, которые привели к изменению HEAD (текущего состояния рабочего каталога). Это может быть полезно для восстановления потерянных коммитов или изменения веток, а затем восстановить его с помощью команды **git checkout**

**git** **show** **–** подробное информация о комите

При слиянии веток обычно создается новый коммит, у подхода **fast-forward** преимущество в том, что не создается дополнительного комита слияния, то есть указатель мастер ветки просто перемещается на последний коммит например feature ветки. Это происходит когда дочерняя ветка вливается в родительскую, при условии что в обеих ветках нет параллельных изменений.

**git merge --no--ff feature** - слияние веток без режима fast forward, при таком слиянии произойдет рекурсивное слияние, то есть стандартное сливание. (Рекурсивное слияние создает новый коммит слияния, который объединяет изменения из обеих веток. Происходит когда и там и там есть параллельные изменения)

При использовании опции squosh создается один коммит объединяющий все изменения в feature ветке

**Git** **cherry**-**pick** создает копию коммита комита другой ветки. Она полезна, когда вы хотите взять определенные изменения из одной ветки и применить их к другой, то есть cherry-pick позволяет выбрать конкретные коммиты, которые мы хотим применить к нашей ветке. Есть похожая команда это **git** **rebase**, которая уже все изменения в одной ветке, и переносит их на другую ветку и в процессе переноса исходная ветка остается неизменной, а все ее коммиты применяются к целевой ветке.

 **rebase** не перемещает коммиты, он создает новые, меняются индекс

**rebase** применяется: 
1. Когда во время работы на фича ветке появляются новые комиты в мастер ветке
2. Доработки в feature-ветке опираются на дополнительные коммиты в мастер ветке, то есть мы можем сменить базирование фича-ветки на новые комиты из мастер ветки (изменяет идентификаторы комитов фича ветки)
3. Фича ветка завершена, ее реализация должна быть добавлена в мастер-ветку без создания коммита слияния (изменения произойдут в режиме фаст-форвард)

**Git diff:** Эта команда используется для отображения различий между коммитами, ветками и т.д.

В Git, **патчи** - это изменения между коммитами, которые можно применить к коду. Они полезны, когда вы хотите поделиться своими изменениями с другими, не делая коммит или push в общий репозиторий.

**Создание** **патча**

git diff > my_patch.patch

Эта команда создаст файл my_patch.patch, который содержит разницу между вашим текущим рабочим каталогом и последним коммитом.

**Применение** **патча**

git apply my_patch.patch

Эта команда применит изменения из файла my_patch.patch к вашему текущему рабочему каталогу.

Команда **git stash** используется для временного сохранения изменений, которые вы сделали, но не хотите коммитить сразу. Это может быть полезно, если вы работаете над чем-то, но вам нужно переключиться на другую задачу. (Работает с незакомиченными изменениями)

**Ветка** – именнованная ссылка на коммит

**git merge** используется для объединения двух или более веток. Это позволяет интегрировать изменения из одной ветки в другую, то есть Git берет коммиты из обеих веток и объединяет их вместе, создавая новый коммит.

**Конфликты:**

При объединении веток могут возникнуть конфликты, если одни и те же строки кода были изменены в обеих ветках. В этом случае Git не сможет автоматически объединить эти изменения, и вам придется вручную разрешить эти конфликты. Решение: можно принять оба изменения, можно выбрать какое то определенное изменение, можно использовать команду **git** **merge** **–****abort**, тем самым вернемся к состоянию до слияния и можем разрешить конфликты.

**Git** **log** **–merge** - чтобы посмотреть файлы, имеющие конфликты слияния, также можно **git** **diff** для большей информации

Если в одной из веток файл менялся, а в другой нет, то в результат слияния попадет более новая измененная версия

**Other:**

Теги используются для указания каких то важных коммитов, обычно обозначается версией

Легкий тег:

**Git tag <name_tag> <id_commit> -** создание тега

**Git** **tag** **–** просмотр тегов (какие есть) **-d** – удалить тег

**Git checkout v1.0**

Аннотированный тег (полноценный объект, который содержит доп. информацию): 
**git tag –a (автор) v1.0 -m "my version 1.0"**


**Интерактивный rebase**: Отличается тем что для каждого комита можно выполнить какую то команду

Git rebase –i HEAD и через тильду кол во коммитов на сколько мы хотим отпрыгнуть назад. После чего открывается список комитов для изменения и список команда которые можно к ним применить.

По умолчанию стоит pick, что означает использовать коммит без изменений

Reword – переименовать сообщение комита

Edit – отредактирвоать коммит (should be edited)

Squash – объединяет коммит с предыдущим

Fix up – тоже самое, только не будет предлагаться изменить описание комита

Drop – удалить коммит (можно просто вручную удалить строку с комитом)

##### **git flow** - методика работы в c Git, модель ветвления, которая предлагает эффективный способ организации работы с гит, позволяет использовать фукнциональные ветки для внедрения фичей и наборы основных веток, которые позволяют нам делать релизы и т.д

В Git Flow используются следующие типы веток:

**Основные ветки:** main и develop. В main хранится официальная история релиза, а develop служит для интеграции новых функций.

**Функциональные ветки** (Feature branches): Создаются для разработки новых функций. Они обычно существуют только в репозиториях разработчиков.

**Ветки релизов** (Release branches): Используются для подготовки нового продуктового релиза.

**Ветки исправлений** (Hotfix branches): Используются для быстрых исправлений в продакшен-релизах.

Примерная работа с git flow:

1. создание функциональной ветки из ветки develop
2. разработка какой то фичи и коммит изменений в эту ветку
3. завершение работы над фичей, после чего сливается обратно в develop
4. когда все фичи для нового релиза готовы в ветке develop создается ветка релиза 
5. После тестирования и устранения ошибок в ветке релиза, она сливается в main и develop.
6. Ветка релиза удаляется, а в main создается новый тег с номером версии.

Плюсы: 
1. Удобный процесс для код ревью (то есть на каждом этапе может проходить кодревью)
Минусы:
1. Возможно будет много merge конфликтов


**GIT CONFIG**

Три уровня настроек:

Локальный: применяются только к текущему репозиторию.

Глобальный: применяются ко всем репозиториям на копьюетере, которые используют нашего пользователя

Системные: независимо от пользователя 