
**Жизненный цикл бина:**

1. Предоставляются BeanDifinition, и попадают в IoC Контейнер

2. Контейнер направляет бин дифинишны в **BeanFactoryPostProcessor** мы можем модифицировать существующие метаданные бинов, до того как они будут созданы. То есть добавлять изменять свойства. Через getBeanDifinition

3. BD сортируются, чтобы осуществить зависимости между ними, в нужном порядке

4. BeanFactory создает бин, на основе BD

5. Проиходит внедрение зависимостей ( сеттеры, конструкторы)

6. Обработка BeanPostProcessor , вызывается BeforeInitializaton

7. Вызывается @PostConstruct (init-method)

8. BeanPostProcessor снова обрабатывает бин вызовом afterInitialization

9. Вызов дестрой методов для синглтона (PreDestroy, destroy() )

![[Pasted image 20240422100205.png]]

**Жизненный цикл контекста состоит из 4-ёх этапов:**

Этап обновления (refresh) - автоматический

Этап запуска (start) - вызывается методом ApplicationContext#start

Этап остановки (stop) - вызывается методом ApplicationContext#stop

Этап закрытия (close) – автоматический

**Разница** **Spring** **и** **SpringBoot**

Spring Boot - это фреймворк, который представляет собой расширение Spring и упрощает процесс создания приложений.

Spring Boot автоматически настраивает необходимые компоненты для приложения, такие как управление зависимостями, внедрение зависимостей, конфигурация и т.д. Также Spring Boot предоставляет встроенный сервер, который позволяет запустить приложение без необходимости настройки внешнего сервера приложений.
  

**Прокси** — это объект, который оборачивает оригинальный бин, добавляя доп. Логику.

  
  

1. **Dynamic Proxy** — если бин реализует хотя бы один интерфейс.

2. **CGLIB** — если бин не реализует никаких интерфейсов. Создается подкласс целевого класса, в подклассе переопределяю.

  
  

**AspectJ** предоставляет методы:

@Aspect

@PointCut определяет где аспект будет определен и применен

@Advice метод с этой аннотацией будет выполнен в тех местах где стоит @PointCut
  

**Transactional**

Propagation = requared ( это распространение по умолчанию. Spring проверяет, существует ли активная транзакция, и, если ничего не существует, создает новую. В противном случае бизнес-логика добавляется к текущей активной транзакции)


Propagation = never (никогда не работает в чужом транзакционном контексте)


Откатывается в случае **непроверяемых** исключений

1. Когда класс или метод помечен @Transactional, Spring создает прокси класс для этого метода или класса

2. Прокси класс оборачивает вызов метода в транзакцию, которая позволяет вводит транзакционную логику до и после вызываемого метода

**Разница Spring AOP и AspectJ**

1. aspectj намного быстрее

2. spring проксирует во время выполнения, aspectj во время компиляции

  
  

**Про 2 транзакшионала**

если 2 метода помечены transcational и один метод вызывает другой, то выполнится только 1 транзакция, вторая не выполнится так как для них создается один общий прокси класс, и оба будут выполнятся в контексте одной и той же транзакции. Отдельный класс, либо самоинджект.

**Прокси**:

Не стоит создавать прокси на этапе beforeInitialization поскольку в метод @PostConstruct передастся уже проксированный бин, что может привести к неточным данным, если допустим инит методы зависят от внутреннего состояния оригинального бина, и так как инит методы будут вызваны уже на прокси, а не на оригинальном бине. Например, инит метод использует поле name для настройки бина, и мы создаем прокси до того как это поле было установлено, то инит метод не будет иметь доступ к оригинальному значению поля name, и если мы изменим какое то поле, то эти изменения не будут отражены в прокси. Поэтому прокси создается на этапе afterInitialization,что бы гарантировать, что прокси будет иметь доступ к актуальному внутреннему состоянию бина. 

То есть, те бин пост процессоры, которые в классе что то меняют, они должны это делать не на этапе beforeInitialization, а на afterInitialization, и PostConstruct работает только с оригинальным классом