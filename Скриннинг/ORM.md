
**`ALL`**: Каскадирует все операции от родительского объекта на дочерний.

1. **`PERSIST`**: Каскадирует операцию сохранения. Если родительский объект сохраняется, то и дочерний объект также будет сохранён.
    
2. **`MERGE`**: Каскадирует операцию слияния. Если родительский объект объединяется, то и дочерний объект также будет объединён.
    
3. **`REMOVE`**: Каскадирует операцию удаления. Если родительский объект удаляется, то и дочерний объект также будет удалён.
    
4. **`REFRESH`**: Каскадирует операцию обновления. Если родительский объект обновляется, то и дочерний объект также будет обновлён.
    
5. **`DETACH`**: Каскадирует операцию отсоединения. Если родительский объект отсоединяется, то и дочерний объект также будет отсоединён.
    

  
  

**EntityManager** — интерфейс для доступа к бд

**PersistanceContext** — набор сущностей, управляемых EntityManager

**Session** - это чисто Hibernate реализация с доп. функционалом

**Session и SessionFactory работают с разными уровнями кэша, так как Session работает в рамках одной сессии и связан с L1 кэшом, SessionFactory связан со множеством сессий и связан с L2 кэшом.**

**Состояния сущностей:**

**NEW** **(TRANSIENT)** — новая сущность

при помощи метожа persist() переходит в состояние **MANAGED**, то есть это означает что PersistanceContext уже есть, сущность получает первичный ключ.

**REMOVED** — это значит что сущность больше не управляется EntityManager, и переходит в **DETACH** (сущность отсоединена от сессии). При помощи метода merge() она снова возвращается в состояние MANAGED

  
  

Метод **flush()** - синхронизирует состояние сессии с БД. Автоматически вызывается в конце транзакции.

**N+1**



EntityGraph — позволяет извлекать связанные сущности в одном запросе, то есть те которые были указаны в EntityGraph аннотации.

То есть у нас есть сущность над которой определяется **@NamedEntityGraph**

**Запросы для загрузки из БД сущностей пишутся на языках:**

- JPQL (JPA) / HQL (Hibernate)

Они позволяют писать запросы, которые гарантированно будут работать с любой БД (нет привязки к конкретной БД).

- Native (На чистом SQL)

- Criteria API

Позволяет писать похожий на SQL запрос, но на языке Java.

- Главное преимущество - удобная работа с динамическими запросами (когда необходимо сформировать запрос в зависимости от входных данных).

МОЖНО ИСПОЛЬЗОВАТЬ IF