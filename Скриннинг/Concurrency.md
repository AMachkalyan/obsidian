 Два вида потоков – **демон** (Служебные потоки, выполняющиеся в фоновом режиме) и **не демон** (основной поток).

**Состояния** **потоков****:

NEW, RUNNABLE, WAITING, TIMED_WAITING, TERMINATED

**Executor & ExecutorService**

Executor – это интерфейс, который предоставляет метод execute(Runnable)

**ExecutorService** расширяет Executor, добавляя методы для управления потоков и методы, которые могут создать Future для отслеживания прогресса одной или нескольких задач

**newFixedThreadPool(int nThreads):**

**newCachedThreadPool()**: Создает пул потоков, который создает новые потоки по мере необходимости, но повторно использует ранее созданные потоки, когда они становятся доступными.

**newSingleThreadExecutor()**: Создает пул, который состоит из единственного рабочего потока. Все задачи выполняются последовательно в порядке их поступления.

**newScheduledThreadPool()**

**Future**
	объект который ожидаем получить в будущем, методом get() можем получить в любом месте.

Реализация ComletableFuturе – содержит множество синхронных и асинхронных методов для работы с результатом, дает возможность строить цепочку асинхронных операций, обработку исключений

**Методы**:

supplyAsync() – используется для асинхронного выполнения задачи, которая возвращает результат

thenAccept() – возвращает результат выполненного действия

thenComposeAsyn() – передает результат одного CF другому

thenCombine()

**livelock** – происходит когда потоки постоянно меняют свое состояние в ответ на дейсвтвия других потоков. Решение: использовать потокобезопасные коллекции либо использовать интерфейс Lock и его имплементацию ReetrantLock с помощью метода tryLock(), который попытается получить блокировку, если она доступна

**Starvation** – ситуация, когда потоки с более низким приоритетом очень долгое время ожидают доступ к ресурсам, пока другие потоки с более высоким приоритетом их освободят, при этом могут создаваться еще такие потоки.

Решение: Можно обновить приоритет потоков на более высокий с помощью метода setPriority() у класса Thread. Min = 1, Norm = 5, Max = 10.

Также можно использовать ReetrantLock, он предоставляет такой параметр, как Firness, который, если установить в true, блокирвока будет передана потоку, который ждёт дольше всех.

**Потокобезопасные коллекции:**

**ConcurrentHashMap** – в отличии от synchronizedMap не блокирует всю коллекцию, а использует концепцию сегментов, где каждый сегмент это как отдельный HashMap. Каждый сегмент имеет свой блокировочный механизм и несколько потоков могут работать с разными сегментами одновременно.

**CopyOnWriteArrayList**/**Set** – алгоритм Copy-On-Write, то есть создается новая копия списка при каждой какой-либо модификации.


**Зачем может быть нужен private мьютекс?**

Объект для синхронизации делается private, чтобы сторонний код не мог на него синхронизироваться и случайно получить взаимную блокировку.

**На каком объекте происходит синхронизация при вызове static synchronized метода?**

У синхронизированного статического метода нет доступа к this, но есть доступ к объекту класса Class, он присутствует в единственном экземпляре и именно он выступает в качестве монитора для синхронизации статических методов.

**Можно ли создавать новые экземпляры класса, пока выполняется static synchronized метод?**

Да, можно создавать новые экземпляры класса, так как статические поля не принадлежат к экземплярам класса.

**AtomicInteger** **хранит свои значения в поле** **volatile****, таким образом, он является декоратором над традиционной volatile, также использует unSave

