**Минусы монолита:**

1. Нельзя создавать сервисы на разных языках
    
2. Труднее расширятся и масштабироваться (слишком громадное приложение становится)
    
3. Падает один сервис, может упасть все приложение
    

**Плюсы монолита:**

1. Больший контроль над всеми сервисами
    
2. Более привычен для разработчиков
    

  
  

**Шаблон «Душитель» (****Strangler****)**

Этот шаблон означает миграцию монолитного приложения на микросервисную архитектуру путем постепенного переноса существующих функций в микросервисы

**Паттерн “Большой Банг”:**

Этот паттерн подразумевает полную и одновременную замену старой системы на новую. Это может быть эффективным для небольших систем, но для больших и сложных систем это может привести к значительным рискам и проблемам

**Паттерн “Параллельные бега”:**

Этот паттерн подразумевает одновременное использование старой и новой системы.

  
  

**RabbitMQ**

Consumer подписывается на одну либо несколько очередей, откуда они хотят получать сообщения, соответсвенно как только Rabbit видит, что в очередь поступило сообщение, он видит какие консюмеры на эту очередь подписаны и если эти консюмеры активны, то сообщение доставляется консюмеру

Exchange может быть связан с несколькими очередями

  

**Типы**

**Direct Exchange** (собщение имеет помимо тела, роутинг кей и сравнивает его с параметрами биндинга, если происходит совпадение, то сообщение попадает в соответсвующуют очередь (сообщения хранятся до того как они будут отправлены консюмеру, консюмер подписывается на одну или несколько очередей откуда они хотят получать события)

**Fanout Exchange** — игнорирует свойсва биндинга, отправляет сообщения во все очереди

Topic - по части заголовка

Header - по заголовку

  
  

**At least once** — хотя бы один раз сообщение может быть доставлено, но при этом может быть доставлено несколько раз.

**At most once —** максимум один раз, но при этом может быть не доставлено

**Exactly once** — каждое сообщение доставляется ровно 1 раз.

  
  

**Kafka**

**Особенности Kafka:** высокая пропускная способность(за счет отправки сообщения пачками, то есть Отказоустойчивость), репликация

  
  

События хранятся в топиках. **Топик** — это такой набор событий одного типа. Топики состоят из **партиций**, и когда продюсер что то пишет он указывает номер партиции в которую он будет писать.

В 1 топик могут писать несколько продюсеров сразу.

  
  

**3 способа определения в какую партицию пойдет сообщение:**

1) Можно явно указать в какую

2) Можно отдать эту задачу кафке и она сама определит в какую партицию (называется round-robin)

3) И определению по ключу (когда мы отправляем сообщение с одним и тем же ключом оно всегда будет попадать в одну и ту же партицию)

Консюмер достает не по одному сообщению, а пачками

Консюмер может читать сообщения из нескольких партиций в топике.

Два консюмера читающие один и тот же топик, образуют группу, _которая для кафки считается как один логический консюмер_

  
  

  
  

**Репликация** — это когда каждая партиция в топике может иметь несколько копий в разных брокерах

Параметр акс определяет сколько подтверждений от брокеров необходимо получить продюсеру, прежде чем считать сообщение успешным.

**Acks = 0** (Продюсер считает сообщение успешно записанным сразу после отправки(обеспечивает максимально пропускную способность))

**acks = 1** Продюсер считает сообщение успешным, после получения подтверждения

**acks** **=** **all** Продюсер считает сообщение успешным после получения подтверждения от всех реплик

Kafka контроллер назначает лидера реплики, операции происходят только с Лидер репликой. Если какой то топик перегружен нужна перебалансировка, в конфиге можем указать размещения.

Лидер рассылает сообщения по фоловерам

Но может быть такое что брокер лидер упал и ему на замену прихоядт:

**ISR insync repl** — когда события пишутся в лидер группу то они синхронно пишутся в ISR фоловеры

**Офсеты** (как отдельный топик) — хранит офсеты для других консюмеров для оповещения о том какое событие было прочитано, таким образом сообщения не дублируются