**Существует три основные разновидности паттернов:**

**Архитектурные паттерны;**

Они нужны для проектирования всей программы, а не отдельных ее элементов.

Например: MVC (Model-View-Controller), Event Sourcing (Событийное ведение), Микросервисы, и т.д.

**Идиомы**;

Идиомы представляют собой паттерны низкого уровня. Их предметная область — реализация той или иной проблемы.



**Паттерны проектирования (дизайн паттерны):**

Порождающие паттерны (Creational Patterns): Они помогают сделать создание объектов более гибким, удобным и независимым от системы.

1) **Синглтон**

2) **Builder**

3) **Factory Method** (Фабричный метод) — является реализацией полиморфизма, то есть главный класс задается интерфейсом или абстрактным классом, а реализация определяется уже подклассами.

  
**Структурные паттерны (Structural Patterns):** определяют отношения объектов для создания более крупных структур.

**Adapter** — позволяет двум разным интерфейсам работать вместе.

**Bridge** - используется для разделения абстракции от реализации, позволяя изменять их независимо друг от друга. (Например, Spring Data JPA позволяет использовать разные источники данных (MySQL, PostgreSQL и др.) без изменения кода репозиториев.)

**Фасад** - Когда вы хотите разложить подсистему на отдельные слои.  
  
  

**Поведенческие паттерны (Behavioral Patterns)**: Эти паттерны управляют взаимодействием между объектами.

1) **ChainOfResponsibility** — позволяет передавать запросы последовательно по цепочке обработчиков. Пример Spring Security FilterChain или ClassLoader

2) **Iterator** — дает возможность последовательно обходить элементы

3) **Observer** — позволяет одним объектам следить и реагировать на различнве события. Например в спринг это EventListener

  
  

**SAGA**

У нас есть сложная транзакция, которая включает несколько этапов, выполняемых в разных микросервисах. Каждый этап вносит изменения. Если в каком-то микросервисе происходит ошибка на одном из этапов, то это может привести к потере данных.

Виды саги:

1) **Оркестратор**.Оркестратор отправляет запрос на выполнение каждого шага и ждет ответ(подтверждение) после чего вызывает другой сервис. Если происходит сбой применяются компекационные действия.

2) **Хореография**. Используется такая, событийная модель, где мы не ожидаем ответ, то есть мы отправляем событие и если кто то заинтересован, он воспользуется этим событием. В случае неудачи, сервис генерирует это событие неудачи, и тот микросервис который отправил событие отслеживает это событие неудачи, и выполнит откат


**Принципы SOLID**

S - **Принцип единственной ответственности (Single Responsibility Principle)**: Каждый класс должен иметь только одну задачу. То есть не должно быть кучи лишней логики не связанной с этим классом

O - **Принцип открытости/закрытости (Open/Closed Principle)**: Классы должны быть открыты для расширения, но закрыты для изменения.

L - **Принцип подстановки Барбары Лисков (Liskov Substitution Principle)**: Подклассы не должны заменять функционал базового класса.

I - **Принцип разделения интерфейса (Interface Segregation Principle):** "Много специализированных интерфейсов лучше, чем один универсальный".

D - **Принцип инверсии зависимостей (Dependency Inversion Principle):** "Зависимость на Абстракциях. Нет зависимости на что-то конкретное".